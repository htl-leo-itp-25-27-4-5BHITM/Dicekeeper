<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Dicekeeper ‚Äì Dungeon Master UI</title>
<link rel="stylesheet" href="../common/header.css">

<style>
* { box-sizing: border-box; }

body {
    margin: 0;
    height: 100vh;
    font-family: "Segoe UI", sans-serif;
    color: #e8f5e9;
    background-image: url("../images/Background.png");
    background-size: cover;
    background-attachment: fixed;
    overflow: hidden;
    padding-top: 60px;
}

/* ===== GRID FIX ===== */

.main {
    height: calc(100vh - 60px);
    display: grid;
    grid-template-columns: 2fr 1.2fr 0.8fr;
    gap: 25px;
    padding: 30px 50px;
}

/* WICHTIG ‚Äì erlaubt Schrumpfen */
.main > * {
    min-height: 0;
}

.glass {
    background: rgba(20, 60, 45, 0.65);
    backdrop-filter: blur(18px);
    border-radius: 25px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

/* ===== MAP ===== */

.map-container {
    justify-content: center;
    align-items: center;
}

.map-box {
    width: 100%;
    height: 100%;
    aspect-ratio: 1/1;
    background: rgba(0,0,0,0.5);
    border-radius: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #9ccc65;
}

/* ===== CENTER COLUMN 50/50 ===== */

.center-column {
    display: flex;
    flex-direction: column;
    gap: 25px;
    height: 100%;
    min-height: 0;
}

.center-column .glass {
    flex: 1;
    min-height: 0;
}

.center-column h3 {
    margin-top: 0;
    flex-shrink: 0;
}

#decisionList {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
}
.decision-card h4,
.decision-card p {
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: break-word;
}

/* Chat Text darf Layout nie sprengen */
.chat-messages div {
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: break-word;
}

.chat-box {
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
    background: rgba(0,0,0,0.4);
    border-radius: 15px;
    padding: 10px;
    margin-bottom: 10px;
    font-size: 14px;
}

/* ===== RIGHT COLUMN ===== */

.right-column {
    display: flex;
    flex-direction: column;
    gap: 25px;
    min-height: 0;
}

.player {
    padding: 15px;
    margin-bottom: 12px;
    border-radius: 18px;
    background: rgba(255,255,255,0.05);
    min-height: 70px;
    cursor: pointer;
    transition: background 0.2s;
}

.player:hover {
    background: rgba(255,255,255,0.12);
}

.player.active {
    background: linear-gradient(90deg, #00c853, #69f0ae);
    color: #003300;
    font-weight: bold;
}

/* ===== CHARACTER MODAL ===== */
.char-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
.char-modal-overlay.visible { display: flex; }

.char-modal {
    width: 420px;
    max-height: 85vh;
    overflow-y: auto;
    background: rgba(20,60,45,0.96);
    backdrop-filter: blur(18px);
    border-radius: 25px;
    padding: 28px 24px;
    color: #e8f5e9;
}
.char-modal h2 { margin: 0 0 4px 0; font-size: 22px; }
.char-modal .char-meta { font-size: 14px; opacity: 0.85; margin-bottom: 18px; line-height: 1.6; }
.char-modal .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 18px; }
.char-modal .stat-box { background: rgba(0,0,0,0.32); border-radius: 14px; padding: 12px 8px; text-align: center; }
.char-modal .stat-label { font-size: 11px; opacity: 0.7; }
.char-modal .stat-value { font-size: 22px; font-weight: 700; margin-top: 2px; }
.char-modal .stat-modifier { font-size: 11px; opacity: 0.8; }
.char-modal .info-box { background: rgba(0,0,0,0.32); border-radius: 14px; padding: 14px; font-size: 14px; line-height: 1.5; white-space: pre-wrap; margin-top: 10px; }
.char-modal .close-btn { margin-top: 16px; width: 100%; padding: 12px; border: none; border-radius: 14px; background: linear-gradient(90deg, #00c853, #69f0ae); color: #003300; font-weight: 700; font-size: 15px; cursor: pointer; }
.char-modal::-webkit-scrollbar { width: 6px; }
.char-modal::-webkit-scrollbar-thumb { background: rgba(100,255,150,0.4); border-radius: 10px; }

/* ===== BUTTONS & INPUTS ===== */

button {
    border: none;
    border-radius: 15px;
    padding: 10px 14px;
    cursor: pointer;
    font-weight: 600;
    margin-top: 5px;
    background: linear-gradient(90deg, #00c853, #69f0ae);
    color: #003300;
}

.purple-btn {
    background: linear-gradient(90deg, #7b1fa2, #ba68c8);
    color: white;
}

select, input, textarea {
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    border: none;
    margin-top: 6px;
    margin-bottom: 10px;
    background: rgba(255,255,255,0.1);
    color: white;
}

/* ===== DECISIONS PANEL ===== */

.decisions-panel {
    position: relative;
}

.decisions-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.decisions-header h3 {
    margin: 0;
    font-size: 16px;
}

.new-decision-btn {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: none;
    background: linear-gradient(135deg, #7b1fa2, #ba68c8);
    color: white;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin: 0;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 2px 8px rgba(123,31,162,0.3);
}

.new-decision-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 14px rgba(123,31,162,0.45);
}

/* Decision empty state */
.decisions-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    opacity: 0.5;
    text-align: center;
    padding: 20px;
}

.decisions-empty-icon {
    font-size: 38px;
    margin-bottom: 10px;
}

.decisions-empty-text {
    font-size: 13px;
    line-height: 1.5;
}

/* ===== DECISION CARDS ===== */

.decision-card {
    background: rgba(0,0,0,0.35);
    padding: 14px 16px;
    border-radius: 16px;
    margin-bottom: 10px;
    border-left: 3px solid #ba68c8;
    transition: border-color 0.2s;
}

.decision-card:hover {
    border-left-color: #ce93d8;
}

.decision-card h4 {
    margin: 0 0 4px 0;
    font-size: 14px;
    font-weight: 700;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: break-word;
    line-height: 1.3;
}

.decision-card .decision-desc {
    font-size: 12.5px;
    opacity: 0.8;
    margin-bottom: 12px;
    line-height: 1.4;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: break-word;
    white-space: pre-wrap;
    max-height: 60px;
    overflow-y: auto;
}

.decision-card .decision-desc::-webkit-scrollbar {
    width: 4px;
}

.decision-card .decision-desc::-webkit-scrollbar-thumb {
    background: rgba(186,104,200,0.3);
    border-radius: 10px;
}

.decision-card .decision-time {
    font-size: 10px;
    opacity: 0.5;
    margin-bottom: 8px;
}

/* Character counter */
.char-counter {
    float: right;
    font-weight: 400;
    opacity: 0.5;
    font-size: 11px;
}

.char-counter.near-limit {
    color: #ffd740;
    opacity: 1;
}

.char-counter.at-limit {
    color: #ff5252;
    opacity: 1;
}

/* Vote bar */
.vote-bar-container {
    margin-top: 8px;
}

.vote-bar-labels {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    margin-bottom: 4px;
    font-weight: 600;
}

.vote-bar-labels .vote-yes { color: #69f0ae; }
.vote-bar-labels .vote-no  { color: #ff5252; }

.vote-bar {
    width: 100%;
    height: 8px;
    background: rgba(255,255,255,0.08);
    border-radius: 99px;
    overflow: hidden;
    display: flex;
}

.vote-bar-yes {
    height: 100%;
    background: linear-gradient(90deg, #00c853, #69f0ae);
    border-radius: 99px 0 0 99px;
    transition: width 0.4s ease;
}

.vote-bar-no {
    height: 100%;
    background: linear-gradient(90deg, #ff5252, #ff8a80);
    border-radius: 0 99px 99px 0;
    transition: width 0.4s ease;
}

.vote-buttons {
    margin-top: 10px;
    display: flex;
    gap: 8px;
}

.vote-btn {
    flex: 1;
    padding: 7px 0;
    border: none;
    border-radius: 10px;
    font-weight: 700;
    font-size: 12px;
    cursor: pointer;
    transition: transform 0.15s, opacity 0.15s;
    margin: 0;
}

.vote-btn:hover {
    transform: scale(1.03);
}

.vote-btn:active {
    transform: scale(0.97);
}

.vote-btn-yes {
    background: rgba(105,240,174,0.15);
    color: #69f0ae;
    border: 1px solid rgba(105,240,174,0.3);
}

.vote-btn-no {
    background: rgba(255,82,82,0.15);
    color: #ff8a80;
    border: 1px solid rgba(255,82,82,0.3);
}

.vote-total {
    text-align: center;
    font-size: 10px;
    opacity: 0.45;
    margin-top: 6px;
}

/* ===== DECISION MODAL REDESIGN ===== */

.decision-modal {
    width: 440px;
}

.decision-modal-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 18px;
}

.decision-modal-header span {
    font-size: 28px;
}

.decision-modal-header h3 {
    margin: 0;
    font-size: 18px;
}

.modal-label {
    font-size: 12px;
    font-weight: 600;
    opacity: 0.7;
    margin-bottom: 2px;
    display: block;
}

.decision-modal input,
.decision-modal textarea {
    background: rgba(255,255,255,0.07);
    border: 1px solid rgba(255,255,255,0.12);
    transition: border-color 0.2s;
}

.decision-modal input:focus,
.decision-modal textarea:focus {
    outline: none;
    border-color: #ba68c8;
}

.decision-modal-actions {
    display: flex;
    gap: 10px;
    margin-top: 8px;
}

.modal-cancel-btn {
    flex: 1;
    padding: 11px;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 12px;
    background: transparent;
    color: rgba(255,255,255,0.7);
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
}

.modal-cancel-btn:hover {
    background: rgba(255,255,255,0.06);
}

.modal-save-btn {
    flex: 1;
    padding: 11px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, #7b1fa2, #ba68c8);
    color: white;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.2s;
}

.modal-save-btn:hover {
    transform: scale(1.02);
    box-shadow: 0 4px 14px rgba(123,31,162,0.4);
}

.vote-area {
    margin-top: 10px;
    display: flex;
    gap: 10px;
}

/* ===== MODAL ===== */

.modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
}

.modal-content {
    width: 400px;
    background: rgba(20,60,45,0.95);
    padding: 25px;
    border-radius: 20px;
}

/* ===== SCROLLBAR ===== */

#decisionList::-webkit-scrollbar,
.chat-messages::-webkit-scrollbar {
    width: 6px;
}

#decisionList::-webkit-scrollbar-thumb,
.chat-messages::-webkit-scrollbar-thumb {
    background: rgba(100,255,150,0.4);
    border-radius: 10px;
}
.player-container {
    overflow-y: auto;
    min-height: 0;
}

/* Scrollbar f√ºr Spieler */
.player-container::-webkit-scrollbar {
    width: 6px;
}

.player-container::-webkit-scrollbar-thumb {
    background: rgba(100,255,150,0.4);
    border-radius: 10px;
}

/* ===== W√ºrfel ===== */
.dice-section {
    gap: 0;
}

.dice-section h3 {
    margin: 0 0 14px 0;
    font-size: 16px;
    flex-shrink: 0;
}

.dice-display {
    position: relative;
    width: 100%;
    aspect-ratio: 2.2 / 1;
    background: rgba(0,0,0,0.4);
    border-radius: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-bottom: 14px;
    overflow: hidden;
    flex-shrink: 0;
}

.dice-display::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 18px;
    border: 1px solid rgba(105,240,174,0.15);
    pointer-events: none;
}

.dice-type-label {
    font-size: 12px;
    opacity: 0.5;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 2px;
}

.dice-result-value {
    font-size: 52px;
    font-weight: 800;
    background: linear-gradient(180deg, #e8f5e9, #69f0ae);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
    transition: transform 0.3s ease;
}

.dice-result-value.rolling {
    animation: diceRoll 0.5s ease-out;
}

@keyframes diceRoll {
    0%   { transform: scale(0.5) rotate(-15deg); opacity: 0.3; }
    50%  { transform: scale(1.15) rotate(5deg); opacity: 1; }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

.dice-feedback-text {
    font-size: 12px;
    min-height: 18px;
    margin-top: 4px;
    font-weight: 600;
    transition: opacity 0.3s;
}

/* Dice type selector chips */
.dice-chip-row {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 12px;
    flex-shrink: 0;
}

.dice-chip {
    padding: 5px 10px;
    border-radius: 99px;
    border: 1px solid rgba(105,240,174,0.2);
    background: rgba(105,240,174,0.06);
    color: rgba(232,245,233,0.7);
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    margin: 0;
}

.dice-chip:hover {
    background: rgba(105,240,174,0.12);
    color: #e8f5e9;
}

.dice-chip.selected {
    background: linear-gradient(135deg, #00c853, #69f0ae);
    color: #003300;
    border-color: transparent;
    box-shadow: 0 2px 10px rgba(0,200,83,0.3);
}

/* Roll button */
.roll-btn {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 14px;
    background: linear-gradient(135deg, #00c853, #69f0ae);
    color: #003300;
    font-weight: 800;
    font-size: 15px;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.2s;
    margin: 0 0 10px 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    flex-shrink: 0;
}

.roll-btn:hover:not(:disabled) {
    transform: scale(1.02);
    box-shadow: 0 4px 16px rgba(0,200,83,0.35);
}

.roll-btn:active:not(:disabled) {
    transform: scale(0.98);
}

.roll-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
}

/* Manual input area */
.manual-row {
    display: flex;
    gap: 8px;
    align-items: stretch;
    flex-shrink: 0;
}

.manual-row input {
    flex: 1;
    margin: 0;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.07);
    color: white;
    font-size: 14px;
    transition: border-color 0.2s;
}

.manual-row input:focus {
    outline: none;
    border-color: #ba68c8;
}

.manual-row input::placeholder {
    color: rgba(255,255,255,0.35);
}

.manual-set-btn {
    padding: 10px 16px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, #7b1fa2, #ba68c8);
    color: white;
    font-weight: 700;
    font-size: 13px;
    cursor: pointer;
    white-space: nowrap;
    transition: transform 0.15s, box-shadow 0.2s;
    margin: 0;
}

.manual-set-btn:hover {
    transform: scale(1.03);
    box-shadow: 0 3px 12px rgba(123,31,162,0.35);
}

.or-divider {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 8px 0;
    flex-shrink: 0;
}

.or-divider::before,
.or-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: rgba(255,255,255,0.1);
}

.or-divider span {
    font-size: 11px;
    opacity: 0.4;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.input-error {
    border: 2px solid #ff5252;
}

.success-feedback {
    color: #69f0ae;
    font-size: 14px;
    margin-top: 5px;
}
</style>
</head>
<body>


<div class="main">

    <div class="map-container glass">
        <div class="map-box">
            Map Bereich (Dungeon Master View)
        </div>
    </div>

    <div class="center-column">

        <div class="glass equal-box decisions-panel">
            <div class="decisions-header">
                <h3>‚öñÔ∏è Gruppenentscheidungen</h3>
                <button class="new-decision-btn" onclick="openDecisionModal()" title="Neue Entscheidung">+</button>
            </div>
            <div id="decisionList"></div>
        </div>

        

       <div class="glass equal-box chat-box">
                    <h3>Dungeon Master Chat</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Nachricht eingeben">
            <button onclick="sendMessage()">Senden</button>
        </div>

    </div>

    <div class="right-column">

        <div class="glass player-container">
            <h3>Spieler</h3>
            <div id="playerList"></div>
        </div>
         <div class="glass dice-section">
            <h3>üé≤ W√ºrfel</h3>

            <div class="dice-display">
                <div class="dice-type-label" id="diceTypeLabel">D20</div>
                <div class="dice-result-value" id="diceResult">‚Äî</div>
                <div class="dice-feedback-text" id="diceFeedback"></div>
            </div>

            <div class="dice-chip-row" id="diceChipRow">
                <button class="dice-chip" data-sides="4">d4</button>
                <button class="dice-chip" data-sides="6">d6</button>
                <button class="dice-chip" data-sides="8">d8</button>
                <button class="dice-chip" data-sides="10">d10</button>
                <button class="dice-chip" data-sides="12">d12</button>
                <button class="dice-chip selected" data-sides="20">d20</button>
                <button class="dice-chip" data-sides="100">d100</button>
            </div>

            <button class="roll-btn" id="rollBtn" onclick="rollDice()">üé≤ W√ºrfeln</button>

            <div class="or-divider"><span>oder</span></div>

            <div class="manual-row">
                <input type="number" id="manualInput" min="1" step="1" placeholder="Manuell‚Ä¶">
                <button class="manual-set-btn" onclick="saveResult()">Setzen</button>
            </div>
        </div>

    </div>
   

</div>

<div id="decisionModal" class="modal" onclick="if(event.target===this) closeDecisionModal()">
    <div class="modal-content decision-modal">
        <div class="decision-modal-header">
            <span>‚öñÔ∏è</span>
            <h3>Neue Gruppenentscheidung</h3>
        </div>
        <label class="modal-label">Titel <span id="titleCounter" class="char-counter">0 / 60</span></label>
        <input type="text" id="decisionTitle" placeholder="z.B. Welchen Pfad nehmen wir?" maxlength="60" oninput="updateCounter('decisionTitle','titleCounter',60)">
        <label class="modal-label">Beschreibung <span id="textCounter" class="char-counter">0 / 200</span></label>
        <textarea id="decisionText" rows="4" placeholder="Beschreibe die Entscheidung f√ºr deine Spieler..." maxlength="200" oninput="updateCounter('decisionText','textCounter',200)"></textarea>
        <div class="decision-modal-actions">
            <button class="modal-cancel-btn" onclick="closeDecisionModal()">Abbrechen</button>
            <button class="modal-save-btn" onclick="saveDecision()">‚úì Erstellen</button>
        </div>
    </div>
</div>

<div id="charModalOverlay" class="char-modal-overlay" onclick="closeCharModal(event)">
  <div class="char-modal" id="charModalContent" onclick="event.stopPropagation()">
  </div>
</div>

<script>
const params = new URLSearchParams(window.location.search);
const campaignId = params.get("campaignId");

let players = [];
let currentIndex = 0;
let decisions = [];
let eventSource = null;

// ===== SSE CONNECTION =====
function connectSSE() {
    if (!campaignId) return;
    eventSource = new EventSource('/api/campaign/' + campaignId + '/sse');

    eventSource.addEventListener('connected', function(e) {
        console.log('SSE connected', JSON.parse(e.data));
    });

    eventSource.addEventListener('turn', function(e) {
        const data = JSON.parse(e.data);
        const idx = players.findIndex(p => p.id === data.playerId);
        if (idx >= 0) {
            currentIndex = idx;
            renderPlayers();
        }
    });

    eventSource.addEventListener('dice', function(e) {
        const data = JSON.parse(e.data);
        // Show incoming dice roll from players in chat
        if (data.playerId && data.playerName !== 'Dungeon Master') {
            const chat = document.getElementById("chatMessages");
            const div = document.createElement("div");
            div.innerHTML = "üé≤ <strong>" + escapeHTML(data.playerName) + "</strong> w√ºrfelt " + escapeHTML(data.diceType) + ": <strong>" + data.result + "</strong>";
            div.style.color = "#ba68c8";
            chat.appendChild(div);
            chat.scrollTop = chat.scrollHeight;
        }
    });

    eventSource.addEventListener('hp', function(e) {
        const data = JSON.parse(e.data);
        const player = players.find(p => p.id === data.playerId);
        if (player) {
            player.hp = data.currentHp;
            player.maxHp = data.maxHp;
            renderPlayers();
        }
    });

    eventSource.addEventListener('decision', function(e) {
        const data = JSON.parse(e.data);
        // Always add from server (we no longer push locally)
        if (!decisions.find(d => d.id === data.id)) {
            decisions.push(data);
            renderDecisions();
        }
    });

    eventSource.addEventListener('vote', function(e) {
        const data = JSON.parse(e.data);
        const d = decisions.find(dec => dec.id === data.decisionId);
        if (d) {
            d.yes = data.yes;
            d.no = data.no;
            renderDecisions();
        }
    });

    eventSource.addEventListener('decision_resolved', function(e) {
        const data = JSON.parse(e.data);
        const d = decisions.find(dec => dec.id === data.decisionId);
        if (d) {
            d.status = 'RESOLVED';
            d.yes = data.yes;
            d.no = data.no;
            d.decisionMade = data.decisionMade;
            renderDecisions();
        }
    });

    eventSource.onerror = function() {
        console.warn('SSE connection lost, reconnecting...');
    };
}

// ===== Load players from DB =====
async function loadPlayers() {
    if (!campaignId) {
        document.getElementById("playerList").innerHTML = "<div style='opacity:0.6'>No campaign selected.</div>";
        return;
    }

    try {
        const cpRes = await fetch('/api/campaign-player/' + campaignId);
        const campaignPlayers = await cpRes.json();
        const playerEntries = campaignPlayers.filter(cp => cp.role === "PLAYER");

        const loaded = [];
        for (const cp of playerEntries) {
            try {
                const pRes = await fetch('/api/player/id/' + cp.playerId);
                if (pRes.ok) {
                    const playerData = await pRes.json();
                    let hp = 10, maxHp = 10;

                    if (cp.characterId) {
                        try {
                            const cRes = await fetch('/api/character/' + cp.characterId);
                            if (cRes.ok) {
                                const charData = await cRes.json();
                                const conScore = charData.abilityScores?.find(a => a.abilityName?.toLowerCase() === 'constitution');
                                const conMod = conScore ? Math.floor((conScore.score - 10) / 2) : 0;
                                const lvl = charData.level || 1;
                                maxHp = 10 + conMod + (lvl - 1) * (6 + conMod);
                                if (maxHp < 1) maxHp = 1;
                                hp = maxHp;
                            }
                        } catch (e) { /* use defaults */ }
                    }

                    loaded.push({
                        id: playerData.id,
                        name: playerData.username || playerData.name || "Unknown",
                        profilePicture: playerData.profilePicture,
                        characterId: cp.characterId,
                        characterStatus: cp.characterStatus,
                        hp: hp,
                        maxHp: maxHp,
                        active: true
                    });
                }
            } catch (e) {
                console.warn("Failed to load player", cp.playerId, e);
            }
        }

        players = loaded;

        // Register all player HP in server game state
        for (const p of players) {
            await fetch('/api/campaign/' + campaignId + '/game/init-hp', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ playerId: p.id, hp: p.hp, maxHp: p.maxHp })
            });
        }

        // Set initial turn
        if (players.length > 0) {
            await fetch('/api/campaign/' + campaignId + '/game/turn', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ playerId: players[0].id, playerName: players[0].name })
            });
        }

        renderPlayers();
    } catch (err) {
        console.error("Failed to load campaign players", err);
        document.getElementById("playerList").innerHTML = "<div style='opacity:0.6'>Failed to load players.</div>";
    }
}

function renderPlayers() {
    const list = document.getElementById("playerList");
    list.innerHTML = "";

    if (players.length === 0) {
        list.innerHTML = "<div style='opacity:0.6; padding:10px;'>No players have joined yet.</div>";
        return;
    }

    players.forEach((player, index) => {
        const div = document.createElement("div");
        div.className = "player" + (index === currentIndex ? " active" : "");

        const hpPct = player.maxHp > 0 ? Math.round((player.hp / player.maxHp) * 100) : 0;
        let hpColor = '#69f0ae';
        if (hpPct <= 50) hpColor = '#ffc107';
        if (hpPct <= 25) hpColor = '#ff5252';

        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span style="cursor:pointer;" class="player-name" data-index="${index}">${player.name}</span>
                <button class="purple-btn" onclick="event.stopPropagation(); toggleActive(${index})" style="padding:6px 10px; font-size:12px;">
                    ${player.active ? "Aussetzen" : "Aktivieren"}
                </button>
            </div>
            <div style="margin-top:8px; font-size:13px;">
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <span>‚ù§Ô∏è</span>
                    <span style="color:${hpColor}; font-weight:700;">${player.hp} / ${player.maxHp}</span>
                    <div style="display:flex; gap:4px; margin-left:auto;">
                        <button onclick="event.stopPropagation(); changePlayerHp(${index}, -1)" style="width:28px; height:28px; border-radius:50%; padding:0; margin:0; font-size:14px; background:rgba(255,82,82,0.2); color:#ff8a80; border:1px solid rgba(255,82,82,0.4); cursor:pointer;">‚àí</button>
                        <button onclick="event.stopPropagation(); changePlayerHp(${index}, -5)" style="width:28px; height:28px; border-radius:50%; padding:0; margin:0; font-size:10px; background:rgba(255,82,82,0.3); color:#ff8a80; border:1px solid rgba(255,82,82,0.4); cursor:pointer;">-5</button>
                        <button onclick="event.stopPropagation(); changePlayerHp(${index}, 5)" style="width:28px; height:28px; border-radius:50%; padding:0; margin:0; font-size:10px; background:rgba(105,240,174,0.2); color:#69f0ae; border:1px solid rgba(105,240,174,0.4); cursor:pointer;">+5</button>
                        <button onclick="event.stopPropagation(); changePlayerHp(${index}, 1)" style="width:28px; height:28px; border-radius:50%; padding:0; margin:0; font-size:14px; background:rgba(105,240,174,0.2); color:#69f0ae; border:1px solid rgba(105,240,174,0.4); cursor:pointer;">+</button>
                    </div>
                </div>
            </div>
        `;

        if (index === currentIndex) {
            div.innerHTML += `
                <div style="margin-top:6px;">
                    <button class="purple-btn" onclick="event.stopPropagation(); nextTurn()" style="width:100%;">Zug beenden</button>
                </div>
            `;
        }

        div.addEventListener("click", () => showCharacterModal(player));
        list.appendChild(div);
    });
}

// ===== HP Change via Server =====
async function changePlayerHp(index, delta) {
    const player = players[index];
    // Optimistic update
    player.hp = Math.max(0, Math.min(player.maxHp, player.hp + delta));
    renderPlayers();

    await fetch('/api/campaign/' + campaignId + '/game/hp', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playerId: player.id, delta: delta })
    });
}

// ===== Character Modal =====
function calculateModifier(score) {
    return Math.floor((score - 10) / 2);
}

function formatModifier(mod) {
    return mod >= 0 ? "+" + mod : "" + mod;
}

async function showCharacterModal(player) {
    const overlay = document.getElementById("charModalOverlay");
    const content = document.getElementById("charModalContent");

    if (!player.characterId) {
        content.innerHTML =
            '<h2>' + player.name + '</h2>' +
            '<div class="char-meta">This player hasn\'t submitted a character yet.</div>' +
            '<button class="close-btn" onclick="closeCharModal()">Close</button>';
        overlay.classList.add("visible");
        return;
    }

    content.innerHTML = '<div style="text-align:center;padding:30px;opacity:0.7;">Loading character...</div>';
    overlay.classList.add("visible");

    try {
        const res = await fetch('/api/character/' + player.characterId);
        if (!res.ok) throw new Error("Character not found");
        const character = await res.json();

        const abilityIcons = {
            Strength: "üí™", Dexterity: "üèπ", Constitution: "üõ°Ô∏è",
            Intelligence: "üß†", Wisdom: "üîÆ", Charisma: "‚ú®"
        };
        const abilities = Object.keys(abilityIcons);

        function getScore(name) {
            const found = character.abilityScores?.find(a =>
                a.abilityName.toLowerCase() === name.toLowerCase()
            );
            return found ? found.score : 10;
        }

        const statsHTML = abilities.map(name => {
            const score = getScore(name);
            const mod = calculateModifier(score);
            return '<div class="stat-box">' +
                '<div class="stat-label">' + abilityIcons[name] + ' ' + name.substring(0,3).toUpperCase() + '</div>' +
                '<div class="stat-value">' + score + '</div>' +
                '<div class="stat-modifier">' + formatModifier(mod) + '</div>' +
            '</div>';
        }).join("");

        content.innerHTML =
            '<h2>' + (character.name || "Unnamed Character") + '</h2>' +
            '<div class="char-meta">' +
                'üë§ Player: ' + player.name + '<br>' +
                'üèÜ Level ' + (character.level || 1) + '<br>' +
                'üß¨ ' + (character.race || "Unknown Race") + '<br>' +
                '‚öîÔ∏è ' + (character.characterClass?.name || "No Class") + '<br>' +
                'üìñ ' + (character.background?.name || "No Background") + '<br>' +
                '‚öñÔ∏è ' + (character.alignment || "Unaligned") +
            '</div>' +
            '<div style="font-weight:600;margin-bottom:8px;">Ability Scores</div>' +
            '<div class="stats-grid">' + statsHTML + '</div>' +
            '<div style="font-weight:600;margin-bottom:6px;">Background Story</div>' +
            '<div class="info-box">' + (character.info || "This hero has not revealed their story yet...") + '</div>' +
            '<button class="close-btn" onclick="closeCharModal()">Close</button>';
    } catch (err) {
        console.error("Failed to load character", err);
        content.innerHTML =
            '<h2>' + player.name + '</h2>' +
            '<div class="char-meta">Failed to load character data.</div>' +
            '<button class="close-btn" onclick="closeCharModal()">Close</button>';
    }
}

function closeCharModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById("charModalOverlay").classList.remove("visible");
}

// ===== Turn Management (synced) =====
async function nextTurn() {
    if (players.length === 0) return;
    let found = false;
    let tries = 0;

    while (!found && tries < players.length) {
        currentIndex = (currentIndex + 1) % players.length;
        if (players[currentIndex].active) {
            found = true;
        }
        tries++;
    }

    renderPlayers();

    // Broadcast to all players via server
    const p = players[currentIndex];
    await fetch('/api/campaign/' + campaignId + '/game/turn', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playerId: p.id, playerName: p.name })
    });
}

function toggleActive(index) {
    players[index].active = !players[index].active;
    if (players.length > 0 && !players[currentIndex].active) {
        nextTurn();
    } else {
        renderPlayers();
    }
}

/* W√ºrfel */
let selectedDiceSides = 20;

document.getElementById("diceChipRow").addEventListener("click", e => {
    const chip = e.target.closest(".dice-chip");
    if (!chip) return;
    document.querySelectorAll(".dice-chip").forEach(c => c.classList.remove("selected"));
    chip.classList.add("selected");
    selectedDiceSides = parseInt(chip.dataset.sides);
    document.getElementById("diceTypeLabel").textContent = "D" + selectedDiceSides;
    manualInput.max = selectedDiceSides;
});

function rollDice() {
    if (manualInput.value.trim() !== "") {
        showFeedback("Manuelles Ergebnis aktiv ‚Äì l√∂sche es zuerst", "#ffd740");
        return;
    }

    const resultEl = document.getElementById("diceResult");
    const rollBtn = document.getElementById("rollBtn");
    rollBtn.disabled = true;

    let ticks = 0;
    const maxTicks = 12;
    const interval = setInterval(() => {
        resultEl.textContent = Math.floor(Math.random() * selectedDiceSides) + 1;
        ticks++;
        if (ticks >= maxTicks) {
            clearInterval(interval);
            const finalResult = Math.floor(Math.random() * selectedDiceSides) + 1;
            resultEl.textContent = finalResult;
            resultEl.classList.remove("rolling");
            void resultEl.offsetWidth;
            resultEl.classList.add("rolling");
            rollBtn.disabled = false;

            if (finalResult === selectedDiceSides && selectedDiceSides === 20) {
                showFeedback("üî• Kritischer Treffer!", "#69f0ae");
            } else if (finalResult === 1 && selectedDiceSides === 20) {
                showFeedback("üíÄ Kritischer Fehlschlag!", "#ff5252");
            } else {
                showFeedback("üé≤ Gew√ºrfelt: " + finalResult, "#69f0ae");
            }

            // Broadcast dice roll to all players
            fetch('/api/campaign/' + campaignId + '/game/dice', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    playerId: null,
                    playerName: 'Dungeon Master',
                    diceType: 'd' + selectedDiceSides,
                    result: finalResult
                })
            });
        }
    }, 55);
}

function saveResult() {
    const manual = parseInt(manualInput.value);

    if (isNaN(manual)) {
        showFeedback("Bitte eine g√ºltige Zahl eingeben", "#ff5252");
        manualInput.classList.add("input-error");
        setTimeout(() => manualInput.classList.remove("input-error"), 1200);
        return;
    }

    if (manual < 1 || manual > selectedDiceSides) {
        showFeedback("Zahl muss zwischen 1 und " + selectedDiceSides + " liegen", "#ff5252");
        manualInput.classList.add("input-error");
        setTimeout(() => manualInput.classList.remove("input-error"), 1200);
        return;
    }

    const resultEl = document.getElementById("diceResult");
    resultEl.textContent = manual;
    resultEl.classList.remove("rolling");
    void resultEl.offsetWidth;
    resultEl.classList.add("rolling");
    showFeedback("‚úì Manuell gesetzt: " + manual, "#69f0ae");
    manualInput.value = "";
    rollBtn.disabled = false;

    // Broadcast manual set to all players
    fetch('/api/campaign/' + campaignId + '/game/dice', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            playerId: null,
            playerName: 'Dungeon Master',
            diceType: 'd' + selectedDiceSides,
            result: manual
        })
    });
}

const manualInput = document.getElementById("manualInput");
const rollBtn = document.getElementById("rollBtn");

manualInput.addEventListener("input", () => {
    rollBtn.disabled = manualInput.value.trim() !== "";
});

manualInput.addEventListener("keydown", e => {
    if (e.key === "Enter") saveResult();
});

function showFeedback(message, color) {
    const fb = document.getElementById("diceFeedback");
    fb.textContent = message;
    fb.style.color = color || "#69f0ae";
    fb.style.opacity = "1";
    setTimeout(() => { fb.style.opacity = "0"; }, 3000);
}

/* Entscheidungen (synced) */
function updateCounter(inputId, counterId, max) {
    const len = document.getElementById(inputId).value.length;
    const counter = document.getElementById(counterId);
    counter.textContent = len + ' / ' + max;
    counter.classList.remove('near-limit', 'at-limit');
    if (len >= max) counter.classList.add('at-limit');
    else if (len >= max * 0.8) counter.classList.add('near-limit');
}

function openDecisionModal() {
    document.getElementById("decisionTitle").value = "";
    document.getElementById("decisionText").value = "";
    updateCounter('decisionTitle', 'titleCounter', 60);
    updateCounter('decisionText', 'textCounter', 200);
    document.getElementById("decisionModal").style.display = "flex";
}

function closeDecisionModal() {
    document.getElementById("decisionModal").style.display = "none";
}

function escapeHTML(str) {
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

async function saveDecision() {
    const title = document.getElementById("decisionTitle").value.trim();
    const text = document.getElementById("decisionText").value.trim();
    if (!title || !text) return;

    const safeTitle = escapeHTML(title);
    const safeText = escapeHTML(text);

    closeDecisionModal();

    // Send to server ‚Äî SSE 'decision' event will add it to our list
    await fetch('/api/campaign/' + campaignId + '/game/decision', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: safeTitle, text: safeText })
    });
}

async function vote(id, type) {
    const d = decisions.find(dec => dec.id === id);
    if (!d || d.status === 'RESOLVED') return;

    // Send vote to server ‚Äî SSE 'vote' event will update the counts
    await fetch('/api/campaign/' + campaignId + '/game/vote', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ decisionId: id, vote: type, playerName: 'Dungeon Master' })
    });
}

function formatTimeAgo(ts) {
    const diff = Math.floor((Date.now() - ts) / 1000);
    if (diff < 60) return "Gerade eben";
    if (diff < 3600) return Math.floor(diff / 60) + " Min.";
    if (diff < 86400) return Math.floor(diff / 3600) + " Std.";
    return Math.floor(diff / 86400) + " Tage";
}

function renderDecisions() {
    const container = document.getElementById("decisionList");
    container.innerHTML = "";

    if (decisions.length === 0) {
        container.innerHTML =
            '<div class="decisions-empty">' +
                '<div class="decisions-empty-icon">‚öñÔ∏è</div>' +
                '<div class="decisions-empty-text">Noch keine Entscheidungen.<br>Klicke <strong>+</strong> um eine neue zu erstellen.</div>' +
            '</div>';
        return;
    }

    decisions.slice().reverse().forEach(d => {
        const total = d.yes + d.no;
        const yesPct = total > 0 ? Math.round((d.yes / total) * 100) : 0;
        const noPct  = total > 0 ? 100 - yesPct : 0;
        const isResolved = d.status === 'RESOLVED';

        container.innerHTML +=
        '<div class="decision-card" style="' + (isResolved ? 'opacity:0.7; border-left: 3px solid #69f0ae;' : '') + '">' +
            '<div class="decision-time">' +
                (isResolved ? '‚úÖ Abgeschlossen' : 'üïê ' + formatTimeAgo(d.createdAt || d.id)) +
                (d.totalPlayers ? ' ¬∑ ' + total + '/' + d.totalPlayers + ' Stimmen' : '') +
            '</div>' +
            '<h4>' + d.title + '</h4>' +
            '<div class="decision-desc">' + d.text + '</div>' +
            (total > 0 ?
            '<div class="vote-bar-container">' +
                '<div class="vote-bar-labels">' +
                    '<span class="vote-yes">üëç Ja ' + yesPct + '%</span>' +
                    '<span class="vote-no">üëé Nein ' + noPct + '%</span>' +
                '</div>' +
                '<div class="vote-bar">' +
                    '<div class="vote-bar-yes" style="width:' + yesPct + '%"></div>' +
                    '<div class="vote-bar-no" style="width:' + noPct + '%"></div>' +
                '</div>' +
            '</div>' : '') +
            (isResolved
                ? '<div style="text-align:center;padding:8px;font-weight:700;color:#69f0ae;">Ergebnis: ' + (d.decisionMade || (d.yes >= d.no ? 'Ja' : 'Nein')) + '</div>'
                : '<div class="vote-buttons">' +
                    '<button class="vote-btn vote-btn-yes" onclick="vote(' + d.id + ', \'yes\')">üëç Ja (' + d.yes + ')</button>' +
                    '<button class="vote-btn vote-btn-no" onclick="vote(' + d.id + ', \'no\')">üëé Nein (' + d.no + ')</button>' +
                  '</div>') +
            (total > 0 && !isResolved ? '<div class="vote-total">' + total + ' Stimme' + (total !== 1 ? 'n' : '') + ' abgegeben</div>' : '') +
        '</div>';
    });
}

/* Chat */
function sendMessage() {
    const input = document.getElementById("chatInput");
    const msg = input.value.trim();
    if (!msg) return;

    const chat = document.getElementById("chatMessages");
    const div = document.createElement("div");
    div.innerHTML = "<strong>Dungeon Master:</strong> " + escapeHTML(msg);
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
    input.value = "";
}

document.getElementById("chatInput").addEventListener("keydown", e => {
    if (e.key === "Enter") sendMessage();
});

// ===== INIT =====
async function loadDecisions() {
    if (!campaignId) return;
    try {
        const res = await fetch('/api/campaign/' + campaignId + '/game/decisions');
        if (res.ok) {
            decisions = await res.json();
            renderDecisions();
        }
    } catch(e) { console.warn('Failed to load decisions', e); }
}

connectSSE();
loadPlayers();
loadDecisions();

</script>


<script src="../common/header.js" defer></script>
</body>
</html>